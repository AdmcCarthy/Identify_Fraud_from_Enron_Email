<h1 id="identify-fraud-from-enron-email">Identify Fraud from Enron Email</h1>
<p><em>Adam McCarthy</em></p>
<p><em>Problem posed in Udacity Intro to machine learning</em></p>
<h2 id="getting-started">Getting Started</h2>
<p>Following the biggest corporate scandal in American history can emails and financial information be used to predict predict persons of interest in the subsequent criminal investigations.</p>
<p>To test results:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">tester.py</span></code></pre>
<p>To re-run and store the classifier, and processed data set:</p>
<pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">poi_id.py</span></code></pre>
<p>View <a href="https://admccarthy.github.io/Identify_Fraud_from_Enron_Email/">report</a> on GitHub pages.</p>
<h2 id="introduction">Introduction</h2>
<p>The question and data set are provided in UdacityÂ´s introduction to machine learning. The question is to identify a label (person of interest) using a predictive model. To predict those in the Enron scandal who were under some form of investigation and deemed the title, person of interest.</p>
<p>Machine learning is used here to predict if a person is of interest or not based on a large number of variables. Machine learning can work through the high number of variables (high dimensionality) in ways that a human manually interpreting and assessing the data will not be able to achieve.</p>
<p><img src="docs\images\Screen_Shot.png" alt="image" /></p>
<p>Screen shot from udacity intro to machine learning course.</p>
<p>This report will work through the stages of a machine learning investigation. It will begin by giving an overview of the dataset and some insights from exploratory data analysis.</p>
<p>It will then move onto to feature selection, scaling and engineering.</p>
<p>It will discuss the approach taken to validate and tune the algorithm and which metrics are used to evaluate the quality of the model.</p>
<p>Following this will be a review of the different approaches taken and their results.</p>
<p>The objective is to find a methodology which can achieve 0.3 or greater in both precision and recall.</p>
<h2 id="overview-of-data">Overview of data</h2>
<p>The analysis of the data includes:</p>
<p><a href="https://github.com/AdmcCarthy/Identify_Fraud_from_Enron_Email/blob/master/resources/notebooks/Exploring%20the%20Enron%20Dataset.ipynb">Jupyter Notebook</a> Exploring the dataset</p>
<p><a href="https://github.com/AdmcCarthy/Identify_Fraud_from_Enron_Email/blob/master/resources/notebooks/Exploring%20Enron%20Email%20Data.ipynb">Jupyter Notebook</a> Exploring the email data</p>
<p><a href="https://admccarthy.github.io/Identify_Fraud_from_Enron_Email/">Report</a> for Exploratory data analysis using R markdown</p>
<h3 id="person-of-interest---label-to-be-predicted">Person of interest - Label to be predicted</h3>
<p>The predicted label is the person of interest (POI). A person of interest reflects those in the Enron case who have been indicted, settled without admitting guilt or testified in exchange for immunity.</p>
<p>The list of POIs has been generated by Udacity. The list was hand drafted from various sources so could contain errors.</p>
<p>There are 35 persons of interest in total 30 of which worked for Enron.</p>
<p>Jeffrey Skilling was the CEO during the fraud period.</p>
<p>Kenneth Lay was chairman.</p>
<p>Andrew Fastow was CFO.</p>
<h3 id="email-dataset">Email dataset</h3>
<p>The email dataset is from <a href="https://www.cs.cmu.edu/~./enron/">here</a></p>
<p>Email dataset consists of 150 directories each reflecting a person, specified as the last name followed by the first letter of the first name.</p>
<p>There are 86 people with email data.</p>
<p>Within <a href="https://github.com/AdmcCarthy/Identify_Fraud_from_Enron_Email/blob/master/resources/other/poi_names.txt">poi_names.txt</a> it can be seen with a yes (y), no (n) column if the poi has an email directory in the dataset.</p>
<h3 id="financial-dataset">Financial dataset</h3>
<p>The financial information is sourced from the <a href="https://github.com/AdmcCarthy/Identify_Fraud_from_Enron_Email/blob/master/resources/other/enron61702insiderpay.pdf">Enron insiderpay pdf</a> which is from Case No. 01-16034.</p>
<p>There are POIs who have email information but do not have financial information.</p>
<p>Non-POIs all come from the financial spreadsheet.</p>
<p>Only POIs or non-POIs who have financial information are used as combining POIs without any financial information, i.e. they have all NaN values for financial data will cause issues with the machine learning process.</p>
<p>An alternative approach would be to only use email information to be able to expand the POI and non-POI dataset but that will not be taken further here.</p>
<p>There are anomalous values in the dataset.</p>
<p>One person value is TOTAL, which gives a sum of values, rather than relating to being a person. This is removed during the data processing pipeline.</p>
<h3 id="enron-final-project-dataset">Enron Final Project dataset</h3>
<p>The dataset created by Udacity is aggregated to contain email and financial information.</p>
<p>It is set up as a key value pair where each key is a person with all the features stored in a dictionary as that person value.</p>
<p>There are 146 persons within the dataset. For each person there are 21 variables.</p>
<p>The dataset contains data on 18 of the POIs.</p>
<p>Note that when missing values occur featureFormat() and targetFeatureSplit() will replace this with 0.</p>
<p>Most of the values have a range of missing parameters, see table below.</p>
<p>This will be challenging for the machine learning process, a feature selection process will be useful to remove any variables that are not informative, e.g. director fees has 129 missing values so is unlikely to be well suited within a predictive model.</p>
<p>The TOTAL key relates to an erroneous input, it is an order of magnitude larger than other values. It is the sum of all people in the dataset and is removed using:</p>
<p>Other large values have been checked and are associated with real people. See enron61702insiderpay.pdf for evidence.</p>
<h2 id="email-variables">Email Variables</h2>
<p>The variables are:</p>
<ul>
<li>Email address</li>
<li>From messages</li>
<li>From poi to this person</li>
<li>From this person to poi</li>
<li>Shared receipt with poi</li>
<li>To messages</li>
</ul>
<p>Email address is a string of the persons email address, it is not a useful variable for making a predictive model so is not included in the machine learning.</p>
<p>See feature engineering for more information on email variables.</p>
<h2 id="financial-variables">Financial variables</h2>
<ul>
<li>Bonus</li>
<li>Deferral payments</li>
<li>Deferred income</li>
<li>Director fees</li>
<li>Exercised stock options</li>
<li>Expenses</li>
<li>Loan advances</li>
<li>Long term incentive</li>
<li>Other</li>
<li>Restricted stock</li>
<li>Restricted stock deferred</li>
<li>Salary</li>
<li>Total payments</li>
<li>Total stock value</li>
</ul>
<p>Bonuses are highly skewed with top bonuses being exceedingly high.</p>
<p><img src="docs\images\Top_Bonuses.png" alt="image" /></p>
<p>95 have salary information. The minimum is 477$. The lowest salary seems a strange number for salary.</p>
<p><img src="docs\images\Top_Salaries.png" alt="image" /></p>
<p>Salary can be compared to bonus as these are two variables that may be correlated.</p>
<p><img src="docs\images\salary_bonus.png" alt="image" /></p>
<p>The plot also splits the data into two sets to view how a linear regression model would behave. The data has a large spread with a couple of key outliers. These outliers mean that a linear model is only useful for the cluster of values associated with lower salary and smaller bonuses. The outliers drag the regression model, for example, see the blue trend line.</p>
<p>All outliers are interesting data points. High salary, high bonus pairs are the top paid in the company.</p>
<p><img src="docs\images\bivariate_finacial.png" alt="image" /></p>
<p>Using frequency polygons on each of the variables and splitting them into groups of POI and non-POI gives a quick way to see if any of the variables stand out as important.</p>
<p>In this case, few variables stand out. Loan advances is due to so few people having this value.</p>
<p>Restricted stock deferred has no members in POI which will limit the use of this variable.</p>
<p><img src="docs\images\financial_1.png" alt="image" /></p>
<p>Using multivariate analysis to try and separate POIs from non-POIs is challenging with the financial variables. An initial assumption may be that salary, bonus and total payments are important, those committing crimes may have been receiving more money.</p>
<p>The plot shows a few of these cases with extreme outliers away from the main cluster like Kenne Lay and Jerrefry Skilling but there are also a number of POIs within the main cluster of people.</p>
<p>Some of the figures here are astonishing. The high figures and skewed distribution suggests a number of these datasets are over dispersed.</p>
<p>There are also some suspicious low values like the minimum salary.</p>
<p>A different feature engineering approach could be to bin the values, for example using log spacing between bins. This will not be attempted during this first pass.</p>
<h2 id="outlier-removal">Outlier removal</h2>
<p>TOTAL is removed as this is a sum of all people.</p>
<p>THE TRAVEL AGENCY IN THE PARK is removed as this is not a valid person.</p>
<p>These are removed from the dataset at the start of the data processing pipeline.</p>
<pre class="sourceCode Python"><code class="sourceCode python"><span class="kw">if</span> ro:
    data_dict.pop(<span class="st">&quot;TOTAL&quot;</span>, <span class="ot">None</span>)
    data_dict.pop(<span class="st">&quot;THE TRAVEL AGENCY IN THE PARK&quot;</span>, <span class="ot">None</span>)</code></pre>
<p>It can be turned off by setting ro to FALSE.</p>
<h2 id="feature-selection">Feature selection</h2>
<p>Four ensemble or tree classifiers are run to investigate feature importance. This is using the entire dataset and all variable apart from email address and name of the person.</p>
<p>The prediction is for the target, POI.</p>
<p><img src="docs\images\DT_feature_importance.png" alt="image" /></p>
<p><img src="docs\images\RF_feature_importance.png" alt="image" /></p>
<p><img src="docs\images\AB_feature_importance.png" alt="image" /></p>
<p><img src="docs\images\GB_feature_importance.png" alt="image" /></p>
<p>Exercised stock options is the most important feature in three of the classifiers.</p>
<p>In AdaBoost the deferred income followed by bonus are the most important.</p>
<p>Decision tree does not use many of the variables.</p>
<p>Director fees are consistently low (almost no) importance.</p>
<p>Loan advances are of low importance but has minor impact.</p>
<p>restricted_stock_deferred is either of no importance or of minor importance. Similarly, deferral_payments is of little importance.</p>
<p>This gives four variables with very little importance, Director fees, loan advances, restricted stock deferred and deferral payments.</p>
<p>A way to select these variables will be using a limit on importance. For example, AdaBoost feature importance &lt;0.02 will remove the weakest four variables. Upon implementation a default ratio of 0.01 is used as the cut-off. This is based of the four graphs and experimenting with different values.</p>
<p>The better scores without feature selection shows this is not the best approach for feature selection. See further down in the report for information about logistic regression implementation, this versio uses the total dataset.</p>
<p>After initial trials using this feature selection approach an iterative univariate ANOVA feature selection step is added into the final pipeline. This uses Kbest and iterates through a range of parameters during GridSearchCV to find the best number of features to use. See further in the report for more information.</p>
<h2 id="feature-engineering">Feature engineering</h2>
<p>Within the email data, there are five variables.</p>
<p><img src="docs\images\email_poi.png" alt="image" /></p>
<p>The bubble chart highlights all five variables by combining two in ratios along x and y. These ratios seem suitable candidates for feature engineering.</p>
<p>One takes the ratio of emails from a POI compared to the total number of emails to that person.</p>
<p>The second the ratio of emails to a POI compared to the total number of emails that person has sent.</p>
<p>The idea being that this will highlight persons of interest better than the two variables separately.</p>
<p>When using these ratios the input variables will be removed. So from_messages, to_messages, from_poi_to_this_person and from_this_person_to_poi are not used when using feature engineering.</p>
<p>To check the result of implementing feature engineering the final estimator will be used to check the output results with and without feature engineering.</p>
<p>The three tests are, with feature engineering and therefore</p>
<pre class="sourceCode Python"><code class="sourceCode python">fe = <span class="ot">True</span>  <span class="co"># Feature engineering</span></code></pre>
<p>With parameters:</p>
<blockquote>
<p>&quot;ratio_to_poi&quot;, &quot;ratio_from_poi&quot;</p>
</blockquote>
<p>Without feature engineering and with the original variables included.</p>
<pre class="sourceCode Python"><code class="sourceCode python">fe = <span class="ot">False</span>  <span class="co"># Feature engineering</span></code></pre>
<p>with parameters:</p>
<blockquote>
<p>&quot;from_messages&quot;, &quot;to_messages&quot;, &quot;from_poi_to_this_person&quot;, &quot;from_this_person_to_poi&quot;</p>
</blockquote>
<p>With feature engineering but include original features. Note these will likely be removed by the ANOVA feature selection layer in the pipeline. A grid search will optimize each of these estimators each will have different parameter combinations.</p>
<pre class="sourceCode Python"><code class="sourceCode python">fe = <span class="ot">True</span>  <span class="co"># Feature engineering</span></code></pre>
<p>with parameters:</p>
<blockquote>
<p>&quot;ratio_to_poi&quot;, &quot;ratio_from_poi&quot;, &quot;from_messages&quot;, &quot;to_messages&quot;, &quot;from_poi_to_this_person&quot;, &quot;from_this_person_to_poi&quot;</p>
</blockquote>
<p>Each of these is using the full data set to train on.</p>
<p>With the feature engineering uses k=8 for feature selection.</p>
<p>Without feature engineering uses k=8 for feature selection. There is little performance difference between these two options. This may relate to the overall importance of the email variables compared to the financial variables.</p>
<p>With feature engineering and all variables uses k='all' for feature selection. This led to a surprise, an increase was achieved on both precision and recall. Giving an F1 score or 0.46. This approach leads to the best estimators, further information can be found in the results section, the pipeline with all features.</p>
<p>NOTE with feature engineering and all variables appears to lead to different estimators during each run of the GridSearchCV.</p>
<h2 id="feature-scaling">Feature Scaling</h2>
<p>Feature scaling is often a requirement for effective machine learning.</p>
<p>Exploratory data analysis has shown that even after removing the extreme outlier, TOTAL, a number of the variables have over dispersed data.</p>
<p>A robust scaler can be used for datasets with many outliers. This will use more robust estimates for central tendency and dispersion before scaling the dataset.</p>
<h2 id="cross-validation-and-optimization">Cross-validation and optimization</h2>
<p>To make a classifier that works well on new or unseen data cross validation aids the algorithm from overfitting on the training data.</p>
<p>Firstly the data is separated into a train and test set using train test split, with 30% held back for testing. This gives 29 people for testing and 65 people for training.</p>
<p>The training data is then used further.</p>
<p>By splitting up the available data (e.g. only the training data) into separate groups, these can be used to cross-validate the performance of a classifier.</p>
<p>In sklearn one useful approach is GridSearchCV, which combines cross-validation and parameter optimization.</p>
<p>Each classifier will have a range of parameters that are not learnt when the classifier is fitted to the data. Each of these is passed as arguments. These can have a large impact on the performance of the classifier and fundamentally change how it approaches making predictions using this dataset.</p>
<p>Parameter optimization can be undertaken manually, running different combinations of parameters to see which performs best but GridSearchCV will compare combinations of the classifier parameters and see which performs the best during cross validation.</p>
<p>The cross validation method can be selected, for this use case stratified K fold is used to maintain an even proportion of labels across the folds of data.</p>
<p>Note that when using 3 folds 65 persons become around 22 and 2 folds 32. This means this problem set is always working with a very small dataset. Having a large number of variables will not be a good idea with such a small dataset.</p>
<p>The validation is undertaken using poi_id.py this outputs the accuracy.</p>
<p>After a good estimator is found this is compared to a test set using tester.py. Which gives precision, recall and F1 which can give a better a review of the performance.</p>
<p>A limitation in this approach is by using the performance from the test set this can leak into into the evaluation and lead to overfitting on new data.</p>
<h2 id="evaluation-metrics">Evaluation metrics</h2>
<p>This problem is a skewed binary classification, therefore accuracy is not the best metric to judge the reliability of the evaluation.</p>
<p>There is an asymmetry in this problem, we can optimize for placing more people as innocent or more people as guilty. Or aim for a balance between the two.</p>
<blockquote>
<p>Recall: True Positive / (True Positive + False Negative). Out of all the items that are truly positive, how many were correctly classified as positive. Or simply, how many positive items were 'recalled' from the dataset.</p>
<p>Precision: True Positive / (True Positive + False Positive). Out of all the items labelled as positive, how many truly belong to the positive class.</p>
</blockquote>
<p>A high precision low recall model would give greater confidence that flagged POIs are truly POI but may miss out on POIs. This would be suitable if avoiding flagging innocent people is the most important issue.</p>
<p>A hhigh recall low precision model would find nearly all POIs but also flag others as involved when they are innocent. This would be useful if screening a large number of people to quickly decide who to focus on for further investigation.</p>
<p>A high F1 score with balanced precision and recall is the best of both settings.</p>
<p>The preference here is to achieve a respectable F1 score and recall but focus on precision. We can live with innocent people being flagged up as this model will give an overview of all those who may be POI. Further investigation could then check these predictions. This would work well as a screening tool to quickly evaluate a range of people.</p>
<h2 id="testing-classifiers">Testing classifiers</h2>
<h3 id="default-setting">Default setting</h3>
<p>Using the default setting of one label and one feature we can take an initial review. of the prediction.</p>
<pre class="sourceCode python"><code class="sourceCode python">features_list = [<span class="st">&#39;poi&#39;</span>, <span class="st">&#39;salary&#39;</span>]</code></pre>
<p>The outputs for the initial algorithm (Gaussian Naive Bayes) is compared to three other algorithms.</p>
<p>AdaBoost performs considerably slower.</p>
<p>KMeans gives warning about predicted labels not equal to 0 or 1.</p>
<p>Naive Bayes gives a very high recall value (0.798).</p>
<h3 id="gradient-boosting-classifer">Gradient Boosting Classifer</h3>
<p>After completing a version of the machine learning pipeline including outlier removal, feature selection, feature engineering and feature scaling a gradient boosting classifier is used with GridSearchCv. This means that parameters can be optimized across cross-validations (in this run 2 folds using stratified k fold). The score to optimize on is F1 weighted.</p>
<p>This is not removing any zeros and using all features as input apart from email address and those that duplicate ratio feature engineering.</p>
<p>This evaluation uses a broad parameter grid.</p>
<pre class="sourceCode Python"><code class="sourceCode python">parameters = [{
               <span class="st">&quot;loss&quot;</span>: [<span class="st">&quot;deviance&quot;</span>, <span class="st">&quot;exponential&quot;</span>],
               <span class="co">&quot;n_estimators&quot;</span>: [<span class="dv">120</span>, <span class="dv">300</span>, <span class="dv">500</span>, <span class="dv">800</span>, <span class="dv">1200</span>],
               <span class="co">&quot;max_depth&quot;</span>: [<span class="dv">3</span>, <span class="dv">5</span>, <span class="dv">7</span>, <span class="dv">9</span>, <span class="dv">12</span>, <span class="dv">15</span>, <span class="dv">17</span>, <span class="dv">25</span>],
               <span class="co">&quot;min_samples_split&quot;</span>: [<span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">10</span>, <span class="dv">15</span>, <span class="dv">100</span>],
               <span class="co">&quot;min_samples_leaf&quot;</span>: [<span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">10</span>],
               <span class="co">&quot;subsample&quot;</span>: [<span class="fl">0.6</span>, <span class="fl">0.7</span>, <span class="fl">0.8</span>, <span class="fl">0.9</span>, <span class="dv">1</span>],
               <span class="co">&quot;max_features&quot;</span>: [<span class="st">&quot;sqrt&quot;</span>, <span class="st">&quot;log2&quot;</span>, <span class="ot">None</span>]
               }]</code></pre>
<p>This gives 18000 combinations to try in an exhaustive grid search. This is useful to get an overview of which parameter combinations perform well, however it comes at a computational cost. It takes a number of hours to fit the classifier. This resulted in:</p>
<p>Best classifier score: 0.894907227728 :</p>
<p>{'subsample': 0.8, 'n_estimators': 120, 'max_depth': 25, 'loss':'deviance', 'min_samples_split': 2, 'min_samples_leaf': 2, 'max_features': 'sqrt'}</p>
<p>When applying this method using the testing function the results are:</p>
<p>This method has improved on the original methods but still does not achieve 0.3 for precision and recall.</p>
<p>The 0.45 for precision compared to the 0.19 for recall suggests that it is finding nearly half the POIs but flagging too many non-POIs as guilty.</p>
<h3 id="further-feature-optimization">Further feature optimization</h3>
<p>Removing features with a high number of NaNs includes dropping, restricted_stock_deferred, loan_advances, director_fees, deferral_payments, and deferred_income. These variables have over 100 missing values (apart from deferred_income with 97). The current features passing feature selection are shown here:</p>
<p>['poi', 'deferred_income', 'exercised_stock_options', 'expenses', 'long_term_incentive', 'other', 'restricted_stock', 'salary', 'shared_receipt_with_poi', ' total_payments', 'total_stock_value', 'ratio_to_poi', 'ratio_from_poi']</p>
<p>Of this only deferred_income is currently passing through the feature selection process. Note that bonus has also been dropped. It is suspected that bonus is dropped as it is correlated to a number of other variables, seen in the pair plot during EDA.</p>
<p>Increasing the cutoff to 0.03 drops total_stock_value and shared_receipt_with_poi. This does not improve the results using the current classifier.</p>
<p>The current classifier is likely overfitting the dataset and is giving more precision than recall.</p>
<h3 id="logistic-regression">Logistic Regression</h3>
<p>Ensemble methods like gradient boosting can be prone to overfitting so trying a different model type may lead to different results.</p>
<p>Instead of default, this uses a cut of 0.03:</p>
<pre class="sourceCode Python"><code class="sourceCode python">features_list = feature_selection.selection(
                                             data_dict,
                                             features_list,
                                             clf_fs,
                                             cut_off=<span class="fl">0.03</span>
                                             )</code></pre>
<p>Similar problems occur as when using the previous classifier with a higher precision than recall.</p>
<p>Further approaches like PCA and more advanced feature selection can be undertaken to see if this improves performance.</p>
<h3 id="pipeline---anova-feature-selection-pca-logistic-regression">Pipeline - Anova Feature Selection &gt; PCA &gt; Logistic Regression</h3>
<p>To expand the classifier sklearns pipeline module can be used to expand the number of steps within the classifier. The main purpose of this is to allow grid search cv to explore different combinations automatically rather than performing manual adjustments.</p>
<p>Feature selection will select fixed number of components based on a classification ANOVA (Analysis of variance) statistical test. The grid search can iterate over different numbers of components (k) to explore which number of features removed works best.</p>
<p>Principal component analysis can reduce the dimensionality of the dataset and reduce the number of features used for machine learning further. This is beneficial in this case as there are few training data points and a high variance to the results. The standard PCA method will be applied to the number of components being iterated through the grid search.</p>
<p>The plan is to get better performance by reducing the number of features used in a machine learning algorithm like logistic regresssion. The results are:</p>
<p>Best classifier score: 0.847349475383 : {'r_dim__n_components': 2, 'r_dim__whiten': True, 'clf__C': 0.1, 'anova__k': 8, 'clf__class_weight': 'balanced'}</p>
<p>This just achieves the goal of being above 0.3 for precision and recall. Note that the method uses just 2 components of data based on only 8 features. This suggests that a pipeline approach is a good approach for this problem.</p>
<p>The f1 score here is 0.35, with a higher recall than precision. This suggests that more POI are being found more accurately but there are still a significant proportion of POI who are not identified.</p>
<p>Following creation of estimators, poi_id.py is changed to use all of the data for training. While tester.py is used to compare the results. These give similar results as seen in the table above.</p>
<h3 id="pipeline---with-all-features">Pipeline - With all features</h3>
<p>Following testing of the impact feature engineering has all features were tested including the engineered features and the original features used to create these.</p>
<p>This led to a surprising result, higher performance was achieved using the pipeline and it would often select k='all'. So it is using all features after the initial static feature selection even though a number may have linear correlations or are so sparsely populated.</p>
<p>Furthermore, the pipeline is now unstable during GridSearchCV and will give slightly different estimators which lead to different results when running tester.py to compare performance.</p>
<p>The conclusion is still valid but scores now increase especially for the recall which can achieve above 0.6 and precision above 0.406. One example is below.</p>
<blockquote>
<p>Pipeline(steps=[('anova', SelectKBest(k='all', score_func=&lt;function f_classif at 0x1184416a8&gt;)), ('r_dim', PCA(copy=True, iterated_power='auto', n_components=4, random_state=None, svd_solver='auto', tol=0.0, whiten=True)), ('clf', LogisticRegression(C=100, class_weight='balanced', dual=False, fit_intercept=True, intercept_scaling=1, max_iter=100, multi_class='ovr', n_jobs=1, penalty='l2', random_state=None, solver='liblinear', tol=0.0001, verbose=0, warm_start=False))]) Accuracy: 0.82633 Precision: 0.40632 Recall: 0.65600 F1: 0.50182 F2: 0.58420 Total predictions: 15000 True positives: 1312 False positives: 1917 False negatives: 688 True negatives: 11083</p>
</blockquote>
<h2 id="conclusions">Conclusions</h2>
<p>The logistic regression combined with PCA and ANOVA feature selection offers an estimator which gives above 0.3 for both Precision and Recall. This achieves the objective criteria. This is a balanced model.</p>
<p>Other methods have been attempted. One which is documented is Gradient Boost which overfits the data giving a high precision (0.45) but poor recall, meaning that it is predicting too many cases to be a person of interest.</p>
<p>Further work could be undertaken to improve this. Further optimization could be attempted using Logistic Regression and its parameters.</p>
<p>New features could be generated from the email corpus. Highlighting key a word set (for example related to specific criminal activities like electric grid manipulation) which relates somehow to POI. This would expand the input variables to perhaps include information to improve performance.</p>
<p>Overall this is a challenging case due to the limited size of the dataset and mixed missing values across different people.</p>
<h2 id="code-issues-and-changes">Code issues and changes</h2>
<h3 id="pickle">Pickle</h3>
<p>Changed code in both poi_id.py and tester.py to fit with Python 3 and pickle otherwise a TypeError is returned. Now has to include &quot;rb&quot; (read binary) and &quot;wb&quot; (write binary) instead of &quot;r&quot; and &quot;w&quot; respectively.</p>
<p>From:</p>
<pre class="sourceCode Python"><code class="sourceCode python"><span class="kw">with</span> <span class="dt">open</span>(f, <span class="st">&quot;r&quot;</span>) <span class="ch">as</span> data_file:
    data_dict = pickle.load(data_file)</code></pre>
<p>To:</p>
<pre class="sourceCode Python"><code class="sourceCode python"><span class="kw">with</span> <span class="dt">open</span>(f, <span class="st">&quot;rb&quot;</span>) <span class="ch">as</span> data_file:
    data_dict = pickle.load(data_file)</code></pre>
<h3 id="depreciation-of-cv">Depreciation of CV</h3>
<p>The code returns this warning.</p>
<blockquote>
<p>DeprecationWarning: This module was deprecated in version 0.18 in favor of the model_selection module into which all the refactored classes and functio ns are moved. Also note that the interface of the new CV iterators are different from that of this module. This module w ill be removed in 0.20.</p>
</blockquote>
<p>This has not been corrected as the starter code iterates over the cross-validation objects and requires this.</p>
<h3 id="resources-used">Resources used</h3>
<p>I hereby confirm that this submission is my work. I have cited above the origins of any parts of the submission that were taken from Websites, books, forums, blog posts, GitHub repositories, etc.</p>
<p><a href="http://scikit-learn.org/stable/modules/classes.html">Sklearn API</a></p>
<p><a href="http://scikit-learn.org/stable/modules/preprocessing.html#preprocessing-scaler">Sklearn feature scaling</a></p>
<p><a href="https://stackoverflow.com/questions/24645153/pandas-dataframe-columns-scaling-with-sklearn">Pandas and sklearn scaling</a></p>
<p><a href="http://blog.kaggle.com/2016/07/21/approaching-almost-any-machine-learning-problem-abhishek-thakur/">Random forest parameter range suggestion</a></p>
<p><a href="http://scikit-learn.org/stable/modules/pipeline.html">Sklearn pipeline</a></p>
<p><a href="http://scikit-learn.org/stable/auto_examples/feature_selection/feature_selection_pipeline.html#sphx-glr-auto-examples-feature-selection-feature-selection-pipeline-py">Sklearn pipeline ANOVA feature selection</a></p>
<p><a href="http://scikit-learn.org/stable/auto_examples/plot_digits_pipe.html#sphx-glr-auto-examples-plot-digits-pipe-py">Sklearn pipeline chaining PCA and logistic regression</a></p>
<p><a href="http://scikit-learn.org/stable/modules/feature_selection.html#univariate-feature-selection">Univariate feature selection Sklearn</a></p>
